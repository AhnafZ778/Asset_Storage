<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dune Mesh Shader</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&display=swap');

    :root {
      --breath: 0.5;
      --theme-accent: 255, 87, 34;
      --ui: rgba(255, 255, 255, 0.42);
      --ui-strong: rgba(255, 255, 255, 0.78);
      --ui-dim: rgba(255, 255, 255, 0.28);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'JetBrains Mono', monospace;
      background: #000;
      overflow: hidden;
      height: 100vh;
    }

    #shader-canvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    .film {
      position: fixed;
      inset: 0;
      z-index: 5;
      pointer-events: none;
      background:
        radial-gradient(1200px 600px at 50% 40%, rgba(var(--theme-accent), 0.04), transparent 55%),
        radial-gradient(900px 500px at 60% 65%, rgba(255, 255, 255, 0.03), transparent 60%);
      mix-blend-mode: screen;
      opacity: calc(0.35 + var(--breath) * 0.18);
      transition: opacity 0.15s linear, background 0.8s ease;
    }

    .glow-orb {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      filter: blur(120px);
      mix-blend-mode: screen;
      opacity: calc(0.08 + var(--breath) * 0.12);
      transform: translate3d(var(--tx, 0px), var(--ty, 0px), 0) scale(calc(1.2 + var(--breath) * 0.3));
      transition: opacity 0.2s linear, background 0.8s ease;
      will-change: transform, opacity;
      z-index: 1;
    }

    .glow-1 {
      top: 15%;
      left: 20%;
      width: 450px;
      height: 450px;
      background: radial-gradient(circle, rgba(var(--theme-accent), 0.18) 0%, transparent 70%);
    }

    .glow-2 {
      bottom: 10%;
      right: 15%;
      width: 400px;
      height: 400px;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.04) 0%, transparent 70%);
    }

    .center-content {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 20;
      color: var(--ui);
      font-size: 12px;
      letter-spacing: 0.2px;
      user-select: none;
      text-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }

    .copy-btn {
      background: transparent;
      border: none;
      cursor: pointer;
      opacity: 0.3;
      transition: opacity 0.2s;
      padding: 4px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    }

    .copy-btn:hover { opacity: 0.68; }
    .copy-btn svg { fill: rgba(255, 255, 255, 0.72); }

    

    .theme-label {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 30;
      color: rgba(255,255,255,0.35);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 2px;
      user-select: none;
      transition: all 0.3s ease;
      opacity: 0.6;
    }

    .status {
      position: fixed;
      top: 32px;
      right: 32px;
      z-index: 30;
      display: flex;
      align-items: center;
      gap: 8px;
      color: rgba(255, 255, 255, 0.3);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      user-select: none;
      pointer-events: none;
    }

    .status-dot {
      width: 7px;
      height: 7px;
      background: rgb(34, 197, 94);
      border-radius: 50%;
      box-shadow: 0 0 20px rgba(34, 197, 94, 0.4);
      opacity: calc(0.5 + var(--breath) * 0.4);
      transition: opacity 0.12s linear;
    }

    @media (max-width: 640px) {
      .theme-label { bottom: 85px; }
      .status { right: 12px; top: 12px; }
      .center-content { font-size: 11px; }
    }
  </style>
</head>
<body>
  <canvas id="shader-canvas"></canvas>
  <div class="film"></div>

  <div class="glow-orb glow-1"></div>
  <div class="glow-orb glow-2"></div>

  <div class="center-content">
    <div>...21st-cli...</div>
    <div class="mt-1 flex items-center justify-center gap-2">
      <span>pnpm i 21st.dev</span>
      <button class="copy-btn" id="copyBtn" title="Copy to clipboard">
        <svg id="copyIcon" width="12" height="12" viewBox="0 0 24 24">
          <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
        </svg>
        <svg id="checkIcon" width="12" height="12" viewBox="0 0 24 24" style="display:none;">
          <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
        </svg>
      </button>
    </div>
  </div>

  <div class="theme-label" id="themeLabel">Dune</div>

  <div class="status">
    <div class="status-dot"></div>
    <span>Live</span>
  </div>

  <script>
    const canvas = document.getElementById('shader-canvas');
    const gl = canvas.getContext('webgl', { antialias: true, alpha: true, premultipliedAlpha: false })
      || canvas.getContext('experimental-webgl');

    if (!gl) {
      document.body.innerHTML = '<div style="color:white;padding:24px;font-family:monospace">WebGL not supported.</div>';
      throw new Error('WebGL not supported');
    }

    gl.getExtension('OES_standard_derivatives');

    let speed = 1.0;
    let intensity = 1.5;
    let activeTheme = 'dune';
    let prevTheme = 'dune';
    let transitionStart = 0;
    let transitioning = false;

    const mouse = { x: 0.5, y: 0.5 };
    const mouseSmoothed = { x: 0.5, y: 0.5 };
    window.addEventListener('pointermove', (e) => {
      mouse.x = e.clientX / window.innerWidth;
      mouse.y = 1.0 - e.clientY / window.innerHeight;
    }, { passive: true });

    let dpr = Math.min(window.devicePixelRatio || 1, 2);
    function resize() {
      dpr = Math.min(window.devicePixelRatio || 1, 2);
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    resize();
    window.addEventListener('resize', resize);

    const vertexShaderSource = `
      attribute vec2 position;
      varying vec2 vUv;
      void main() {
        vUv = position * 0.5 + 0.5;
        gl_Position = vec4(position, 0.0, 1.0);
      }
    `;

    const commonGLSL = `
      #ifdef GL_OES_standard_derivatives
      #extension GL_OES_standard_derivatives : enable
      #endif
      precision highp float;
      varying vec2 vUv;
      uniform float time;
      uniform float speed;
      uniform float intensity;
      uniform float fade;
      uniform vec2 resolution;
      uniform vec2 mouse;

      float sat(float x){ return clamp(x, 0.0, 1.0); }

      float hash12(vec2 p) {
        vec3 p3 = fract(vec3(p.xyx) * 0.1031);
        p3 += dot(p3, p3.yzx + 33.33);
        return fract((p3.x + p3.y) * p3.z);
      }

      float noise(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        float a = hash12(i);
        float b = hash12(i + vec2(1.0, 0.0));
        float c = hash12(i + vec2(0.0, 1.0));
        float d = hash12(i + vec2(1.0, 1.0));
        vec2 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);
        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
      }

      mat2 rot(float a) {
        float s = sin(a), c = cos(a);
        return mat2(c, -s, s, c);
      }

      float fbm(vec2 p, float persistence) {
        float f = 0.0;
        float a = 0.5;
        mat2 m = rot(0.5);
        for (int i = 0; i < 7; i++) {
          f += a * noise(p);
          p = m * p * 2.05;
          a *= persistence;
        }
        return f;
      }

      float ease(float x) {
        x = sat(x);
        return x * x * (3.0 - 2.0 * x);
      }

      vec2 aspectCorrect(vec2 uv) {
        vec2 p = uv - 0.5;
        p.x *= resolution.x / resolution.y;
        return p;
      }

      vec3 filmGrain(vec2 fc, float t) {
        return vec3(hash12(fc + vec2(t * 120.0, -t * 80.0)) - 0.5);
      }

      vec3 tonemap(vec3 x) {
        const float a = 2.51;
        const float b = 0.03;
        const float c = 2.43;
        const float d = 0.59;
        const float e = 0.14;
        return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);
      }
    `;

    // MICRO-FOLDING LOGIC
    const folderGLSL = `
      float fold(vec2 p, float t, float b) {
        float f = 0.0;
        mat2 m = rot(0.3 + 0.05 * sin(t * 0.1));
        vec2 q = p;
        for(int i=0; i<5; i++) {
          q = m * q * 1.6 + vec2(sin(t * 0.08), cos(t * 0.12)) * 0.15;
          // Smooth micro-folds
          float n = noise(q + t * 0.04);
          float ridge = 1.0 - abs(n * 2.0 - 1.0);
          f += pow(ridge, 3.0) * pow(0.5, float(i));
        }
        return f * (0.9 + 0.1 * b);
      }
    `;

    // DUNE - Gritty, wind-blown sand
    const duneShader = `
      ${commonGLSL}
      ${folderGLSL}
      void main() {
        float t = time * speed;
        float b = ease(0.5 + 0.5 * sin(t * 0.4));
        vec2 p = aspectCorrect(vUv) + (mouse - 0.5) * 0.08;
        p.x += fbm(p * 0.5 + t * 0.02, 0.5) * 0.2; // Wind drift
        float folding = fold(vec2(p.x * 0.8, p.y * 2.5), t * 0.3, b);
        vec3 sand = vec3(0.9, 0.6, 0.3);
        vec3 shadow = vec3(0.1, 0.05, 0.0);
        vec3 col = mix(shadow, sand, folding);
        col += sand * pow(folding, 5.0) * intensity * 0.5;
        col *= smoothstep(1.2, 0.1, length(p));
        col += filmGrain(gl_FragCoord.xy, t).x * 0.04; // Heavy grit
        gl_FragColor = vec4(tonemap(col) * fade, fade);
      }
    `;


    function compileShader(source, type) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compile error:', gl.getShaderInfoLog(shader));
        return null;
      }
      return shader;
    }

    function createProgram(fragSource) {
      const vs = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
      const fs = compileShader(fragSource, gl.FRAGMENT_SHADER);
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program link error:', gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }

    const programs = {
      dune: createProgram(duneShader),
    };

    const themeAccents = {
      dune: '244, 164, 96',
    };

    const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    gl.disable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    function easeInOutCubic(x) {
      x = Math.max(0, Math.min(1, x));
      return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
    }

    function setUniforms(program, t, fadeVal) {
      gl.useProgram(program);
      gl.uniform1f(gl.getUniformLocation(program, 'time'), t);
      gl.uniform1f(gl.getUniformLocation(program, 'speed'), speed);
      gl.uniform1f(gl.getUniformLocation(program, 'intensity'), intensity);
      gl.uniform2f(gl.getUniformLocation(program, 'resolution'), canvas.width, canvas.height);
      gl.uniform2f(gl.getUniformLocation(program, 'mouse'), mouseSmoothed.x, mouseSmoothed.y);
      gl.uniform1f(gl.getUniformLocation(program, 'fade'), fadeVal);

      const posLoc = gl.getAttribLocation(program, 'position');
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
    }

    const orb1 = document.querySelector('.glow-1');
    const orb2 = document.querySelector('.glow-2');

    let startTime = performance.now();

    function render(now) {
      const t = (now - startTime) / 1000;

      const lerp = 0.065;
      mouseSmoothed.x += (mouse.x - mouseSmoothed.x) * lerp;
      mouseSmoothed.y += (mouse.y - mouseSmoothed.y) * lerp;

      const bt = t * speed;
      let breath = 0.5 + 0.5 * Math.sin(bt * 0.6);
      breath = breath * breath * (3 - 2 * breath);
      document.documentElement.style.setProperty('--breath', breath.toFixed(4));

      const mx = (mouseSmoothed.x - 0.5);
      const my = (mouseSmoothed.y - 0.5);
      const drift1x = (Math.sin(bt * 0.15) * 60 + mx * 50) * (0.5 + breath * 0.5);
      const drift1y = (Math.cos(bt * 0.12) * 50 - my * 40) * (0.5 + breath * 0.5);
      const drift2x = (Math.cos(bt * 0.18) * 40 - mx * 60) * (0.4 + breath * 0.6);
      const drift2y = (Math.sin(bt * 0.14) * 30 + my * 30) * (0.4 + breath * 0.6);

      orb1.style.setProperty('--tx', drift1x.toFixed(2) + 'px');
      orb1.style.setProperty('--ty', drift1y.toFixed(2) + 'px');
      orb2.style.setProperty('--tx', drift2x.toFixed(2) + 'px');
      orb2.style.setProperty('--ty', drift2y.toFixed(2) + 'px');

      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);

      if (transitioning) {
        const elapsed = (t - transitionStart);
        const k = easeInOutCubic(elapsed / 0.8);

        setUniforms(programs[prevTheme], t, 1.0 - k);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        setUniforms(programs[activeTheme], t, k);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        if (k >= 1) transitioning = false;
      } else {
        setUniforms(programs[activeTheme], t, 1.0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);

    const copyBtn = document.getElementById('copyBtn');
    const copyIcon = document.getElementById('copyIcon');
    const checkIcon = document.getElementById('checkIcon');

    copyBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText('pnpm i 21st.dev');
        copyIcon.style.display = 'none';
        checkIcon.style.display = 'block';
        setTimeout(() => {
          copyIcon.style.display = 'block';
          checkIcon.style.display = 'none';
        }, 2000);
      } catch (err) {
        console.error('Failed to copy:', err);
      }
    });
  </script>
</body>
</html>
